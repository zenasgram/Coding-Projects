#include <iostream>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <cmath>

/// you can add other headers as needed
/// but only headers from the standard library
/// and not the algorithm header

/// do not use using namespace std

/// functions for random number generation, do not alter the declarations
void set_random_seed();
int randn(int n);

/// you can define and use additional functions and structs,
/// add here the declarations for any other functions
/// and/or structs you wish to define and use
/// (the implementation for functions that don't belong to a struct
/// should be added after the main)

/// this is the struct definition for the code maker
/// do not alter the name
struct mm_code_maker{

    /// this member function sets the values for the member data
    /// representing the lenght of the code
    /// and the number of symbols (the symbols will be 0 to i_num)
    /// (this should be a constructor in proper OOP but ok)
    /// do not alter this function
    void init(int i_length, int i_num){
        length = i_length;
        num = i_num;
    }

    /// this member function generates a random sequence based
    /// on the length and num parameters stored as member data
    /// do not alter this function
    void generate_sequence(){
        for(int i = 0; i < length; i++){
            sequence.push_back(randn(num));
        }
    }

    /// do not alter name and parameter list for this function
    void give_feedback(const std::vector<int>& attempt, int& black_hits, int& white_hits){
        /// write here your implementation for this function
        /// which takes in input an attempt
        /// and provides feedback in terms of black hits
        /// and white hits (see linked paper)
        black_hits = 0; //reset
        white_hits = 0; //reset
        std::vector<int> skip;
        bool test=true;

          for(int i=0; i < attempt.size(); i++){

              if(attempt[i]==sequence[i]){
                black_hits++;
                skip.push_back(i); //rmb index for black peg (avoid testing against this)
              }
              else{

                  for(int j=0; j<sequence.size(); j++){

                    if(attempt[i]==sequence[j]){
                    //element at this index has been accountedd for already. SKIP
                            for(int k=0; k<skip.size(); k++){
                              if(skip[k]==j){
                                test=false;
                              }
                            }
                    //if test = false, do not add to white_peg count
                        if(test==true && attempt[j]!=sequence[j]){ //no other repeated values
                          white_hits++;
                          skip.push_back(j);
                          j=sequence.size();//break from loop to avoid repeated counts
                        }
                        //reset test for next iteration
                        test=true;
                    }
                }
            }

        }

        //index feedback test
        // std::cout << std::endl;
        // std::cout << "skip index: " << std::endl;
        // for(int k=0; k<skip.size(); k++){
        //   std::cout << skip[k] << " ";
        // }
        // std::cout << std::endl;


    }

    /// member data holding the sequence generated by generate_sequence
    /// do not alter this
    std::vector<int> sequence;

    /// member data holding the values for length of code and number of symbols
    /// do not alter these
    int length;
    int num;

    /// do not add any other member data,
    /// in particular note that any variables needed for function give_feedback
    /// need to be declared within give_feedback
    /// (they are not member data of the struct)

    /// you may add other member functions if needed
};


/// this is the struct definition for the solver, do not alter the name
struct mm_solver{

    /// this member function sets the values for the member data
    /// representing the lenght of the code
    /// and the number of symbols (the symbols will be 0 to i_num)
    /// (this should be a constructor in proper OOP but ok)
    /// do not alter this function
    void init(int i_length, int i_num){
        length = i_length;
        num = i_num;
        first = true;
        index = length-1;
        blackmax = 0;
    }

    /// this member function creates an attempt to find the right code
    /// (see the other examples provided for clarifications)
    /// do not alter the function interface (name, parameter list, void return)
    void create_attempt(std::vector<int>& attempt){
        /// write your implementation here

        //initial attempt
        if(first){
          for(int i=0; i<length; i++){
            attempt.push_back(0);
          }
          first=false;
        }
        else{

          if(num<=8 && length<=8){ //Inconsistency Elimination Method

            std::vector<int> guess;

            int black=0;
            int white=0;

            int found = 0; //counter for
            guess = history_attempt[history_attempt.size()-1]; //let guess be the last used attempt

            bool ready = false;

              while(!ready){

                //increments the vector guess by 1, starting from the first index
                vectinc(guess);

                  for (int i=0; i<history_attempt.size(); i++){

                      give_feedback(guess, history_attempt[i], black, white);
                      //check for inconsistency
                        if(black!=history_black[i] || white!=history_white[i]){
                          //guess is inconsistent
                          //do nothing
                        }
                        else{
                          //guess is consistent,break from loop
                          found++; // current guess is consistent with history_attempt[i]
                        }
                  }

                if(found==history_attempt.size()){
                    ready=true; //guess is consistent with all past attempts
                    attempt = guess; //RETURN consistent guess to setup for next attempt
                }
                else{
                  found=0; //reset found
                }
            } //end of while loop

          }
          else{ //Brute Force Method for very large n

            std::vector<int> guess;
            guess = lastattempt; //set guess to last bestcase attempt

              int tmp = guess[index];

              if(tmp+1 < num){
                guess[index]=tmp+1;
              }
              // else{
              //   guess[index]=0; //set current index to 0
              // }

            attempt = guess;

          }
        }
    }






    /// this member function acquires the feedback about a certain attempt
    /// (see the other examples provided for clarifications)
    /// do not alter the function interface (name, parameter list, void return)
    void learn(std::vector<int>& attempt, int black_hits, int white_hits){
        /// write your implementation here
        if(num<=8 && length<=8){ //Inconsistency Elimination Method
          history_attempt.push_back(attempt);
          history_black.push_back(black_hits);
          history_white.push_back(white_hits);
        }
        else{ //Brute Force Method for very large n


          lastattempt = attempt; //set up for next increment

          if(black_hits>=blackmax){
            blackmax = black_hits; //set next highest comparison
            bestcase = attempt; //store bestcase vector
          }
          //upon finishing one set
          if(attempt[index]==num-1){
            lastattempt[index]=bestcase[index]; //memorize the bestcase for each index
            index--;

            lastattempt[index]=-1; //setup counter for next increment (at new index)

            blackmax = 0; //reset for new index comparison
          }

        }
    }




    //std::vector<std::vector<int> > not_correct; //every invalid combination (regardeless of attempt)
    //std::vector<std::vector<int> > incorrect_guess; //every attempt
    std::vector<std::vector<int> > history_attempt; //stores every past attempt
    std::vector<int> history_black; //stores black hits for past attempts
    std::vector<int> history_white; //stores white hits for past attempts

    std::vector<int> bestcase;
    std::vector<int> lastattempt;
    int blackmax;
    int index;

    int length;
    int num;
    bool first;

    /// you may add other member functions and member data as needed

    //increment vector (limited by num)

    void vectinc(std::vector<int>& vect){
      int i = length-1; //start from left most digit
      while(i>=0){ //break if index is negative
        int tmp = vect[i];
        if(tmp+1 < num){
          vect[i]=tmp+1;
          i = -1; //exit loop
        }
        else{
          vect[i]=0; //set current index to 0
          i--; //shift to next index
        }
      }
    }

    void give_feedback(const std::vector<int>& guess, const std::vector<int>& attempt, int& black_hits, int& white_hits){
        /// write here your implementation for this function
        /// which takes in input an attempt
        /// and provides feedback in terms of black hits
        /// and white hits (see linked paper)
        black_hits = 0; //reset
        white_hits = 0; //reset
        std::vector<int> skip;
        bool test=true;


          for(int i=0; i < guess.size(); i++){

              if(guess[i]==attempt[i]){
                black_hits++;
                skip.push_back(i); //rmb index for black peg (avoid testing against this)
              }
              else{

                  for(int j=0; j<attempt.size(); j++){

                    if(guess[i]==attempt[j]){
                    //element at this index has been accountedd for already. SKIP
                            for(int k=0; k<skip.size(); k++){
                              if(skip[k]==j){
                                test=false;
                              }
                            }
                    //if test = false, do not add to white_peg count
                        if(test==true && guess[j]!=attempt[j]){ //no other repeated values
                          white_hits++;
                          skip.push_back(j);
                          j=attempt.size();//break from loop to avoid repeated counts
                        }
                        //reset test for next iteration
                        test=true;
                    }
                }
            }

        }

  }

    /// (keep in mind the distinction between member function variables
    /// and member data of the struct)

};

/// before the submission you need to remove the main
/// (either delete it or comment it out)
/// otherwise it will intefere with the automated testing

int main(){
    /// write the code for the main here in order to test your functions

//testbench main
float Asum = 0; //attempt sum
float Tsum = 0; //time sum

float Aavg = 0; //attempt average
float Tavg = 0; //time average

int size = 100; //sample size

int worst = 0; //track worst case result
int best = 5000; //track best case result, set to limit 5000

float timelimit = 600;
int samplecount = 0;

        int length, num;
        std::cout << "enter length of sequence and number of possible values:" << std::endl;
        std::cin >> length >> num;
        set_random_seed();

for (int i=0; i<size; i++){

        samplecount++; //keeps track of the number of attempts

        mm_solver solver;
        solver.init(length, num);

        mm_code_maker maker;
        maker.init(length, num);
        maker.generate_sequence();

        int black_hits=0, white_hits=0;
        int attempts_limit = 5000;
        int attempts = 0;
        clock_t start = clock();

        std::cout << "Sample count: " << samplecount << std::endl;

        while((black_hits < length) && (attempts < attempts_limit)){
            std::vector<int> attempt;
            solver.create_attempt(attempt);
            maker.give_feedback(attempt, black_hits, white_hits);
            std::cout << "attempt: " << std::endl;
            for(int i = 0; i < attempt.size(); i++){
                std::cout << attempt[i] << " ";
            }
            std::cout << std::endl;
            std::cout << "black pegs: " << black_hits << " " << " white pegs: " << white_hits << std::endl;
            solver.learn(attempt, black_hits, white_hits);
            attempts++;
            std::cout << std::endl;
        }

        clock_t end = clock();
        float seconds = (float)(end - start) / CLOCKS_PER_SEC;
        std::cout << '\n';
        std::cout << "time: " << seconds << '\n';
        if(black_hits == length){
            std::cout << "the solver has found the sequence in " << attempts << " attempts" << std::endl;
        }
        else{
            std::cout << "after " << attempts << " attempts still no solution" << std::endl;
        }
        std::cout << "the sequence generated by the code maker was:" << std::endl;
        for(int i = 0; i < maker.sequence.size(); i++){
            std::cout << maker.sequence[i] << " ";
        }
        std::cout << std::endl;
        std::cout << std::endl;

        Asum = Asum + attempts;
        Tsum = Tsum + seconds;

        if(attempts > worst){
          worst = attempts;
        }

        if(attempts < best){
          best = attempts;
        }

        if(seconds > timelimit){
          i++;
          size = samplecount; //break from loop
        }

}

        Aavg = Asum/size;
        Tavg = Tsum/size;

        std::cout << std::endl;
        std::cout << std::endl;
        std::cout << "Time average for sample size " << size << " is: " << Tavg << '\n';
        std::cout << "Attempt average for sample size " << size << " is: " << Aavg << '\n';
        std::cout << "Best case: " << best << '\n';
        std::cout << "Worst case: " << worst << '\n';

        if(size < 100){
          std::cout << "Test voided. Status: N.A" << '\n';
        }

        return 0;


//     set_random_seed();
//
// int length, num;
// std::cout << "enter length of sequence and number of possible values:" << std::endl;
// std::cin >> length >> num;
//
// mm_solver solver;
// solver.init(length, num);
//
// mm_code_maker maker;
// maker.init(length, num);
// maker.generate_sequence();
//
// int black_hits=0, white_hits=0;
// int attempts_limit = 5000;
// int attempts = 0;
// while((black_hits < length) && (attempts < attempts_limit)){
//     std::vector<int> attempt;
//     solver.create_attempt(attempt); //generates a sequence based on input length and number of possible values
//     maker.give_feedback(attempt, black_hits, white_hits);
//     std::cout << "attempt: " << std::endl;
//     //print out attempt
//     for(int i = 0; i < attempt.size(); i++){
//         std::cout << attempt[i] << " ";
//     }
//     std::cout << std::endl;
//     //print out feedback
//     std::cout << "black pegs: " << black_hits << " " << " white pegs: " << white_hits << std::endl;
//
//     //learn from feedback
//     solver.learn(attempt, black_hits, white_hits);
//     attempts++;
//     std::cout << std::endl;
//
// }
//
//
// if(black_hits == length){
//     std::cout << "the solver has found the sequence in " << attempts << " attempts" << std::endl;
// }
// else{
//     std::cout << "after " << attempts << " attempts still no solution" << std::endl;
// }
//
// //print created sequence (answer)
// std::cout << "the sequence generated by the code maker was:" << std::endl;
// for(int i = 0; i < maker.sequence.size(); i++){
//     std::cout << maker.sequence[i] << " ";
// }
//
// std::cout << std::endl;
// return 0;
}

/// not a great implementation for set_random_seed and for randn;
/// if you are trying to get better results you may want to change
/// the implementation using C++11 features, see for instance
/// https://isocpp.org/files/papers/n3551.pdf
/// but don't change the interface/declaration of the functions

void set_random_seed(){
    std::srand(std::time(0));
}

int randn(int n){
    return std::rand() % n;
}

/// add here the implementation for any other functions you wish to define and use
